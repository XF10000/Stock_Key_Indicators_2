# 测试用例设计

## 1. 概述

本文档定义了项目的核心测试用例，涵盖单元测试和集成测试，旨在确保代码的质量、正确性和健壮性。所有测试都将使用 `pytest` 框架编写。

## 2. 单元测试用例

### 2.1 `analysis.calculator`

-   **测试对象**: `FinancialCalculator` 类中的每个指标计算方法。
-   **测试策略**: 使用预先构造的、包含边缘情况的 `pandas.DataFrame` 作为输入，验证计算结果的准确性。

| 测试用例 ID | 测试函数 | 描述 | 输入 | 预期输出 |
| :--- | :--- | :--- | :--- | :--- |
| **UC-CALC-001** | `calculate_roe` | 测试正常情况下的 ROE 计算。 | 包含有效“净利润”和“所有者权益”的 DataFrame。 | ROE 计算结果正确。 |
| **UC-CALC-002** | `calculate_roe` | 测试分母（所有者权益）为 0 的情况。 | “所有者权益”为 0 的 DataFrame。 | 对应的 ROE 结果为 `NaN` 或 `inf`，程序不崩溃。 |
| **UC-CALC-003** | `calculate_roe` | 测试输入数据包含 `NaN` 值的情况。 | “净利润”或“所有者权益”为 `NaN` 的 DataFrame。 | 对应的 ROE 结果为 `NaN`。 |
| **UC-CALC-004** | `calculate_roe` | 测试输入为空 DataFrame 的情况。 | 空的 DataFrame。 | 返回一个空的 DataFrame 或抛出预期的异常。 |

*(此模式将应用于所有其他指标的计算函数)*

### 2.2 `data_provider.akshare_client`

-   **测试对象**: `AkshareClient` 类。
-   **测试策略**: 使用 `pytest-mock` 模拟 `akshare` 的 API 响应，以隔离测试数据解析和错误处理逻辑。

| 测试用例 ID | 测试函数 | 描述 | 输入/模拟 | 预期输出 |
| :--- | :--- | :--- | :--- | :--- |
| **UC-AK-001** | `get_financial_report` | 测试成功获取并解析标准格式的数据。 | 模拟 `akshare` 返回一个标准的财务报表 DataFrame。 | 返回一个结构和内容均正确的 DataFrame。 |
| **UC-AK-002** | `get_financial_report` | 测试 API 返回空数据的情况。 | 模拟 `akshare` 返回一个空的 DataFrame。 | 返回一个空的 DataFrame 或 `None`。 |
| **UC-AK-003** | `get_financial_report` | 测试 API 调用抛出异常的情况。 | 模拟 `akshare` 调用时抛出 `Exception`。 | 返回 `None`，并记录错误日志。 |

### 2.3 `data_provider.repository`

-   **测试对象**: `Repository` 类。
-   **测试策略**: 在测试中使用一个临时的、内存中的 SQLite 数据库，以验证数据的存取逻辑。

| 测试用例 ID | 测试函数 | 描述 | 输入 | 预期输出 |
| :--- | :--- | :--- | :--- | :--- |
| **UC-REPO-001** | `save_financial_report` | 测试数据能否被成功写入数据库。 | 一个包含财务数据的 DataFrame。 | 数据被正确写入内存数据库中。 |
| **UC-REPO-002** | `get_financial_data` | 测试能否从数据库中正确读出数据。 | 在数据库中预先存入数据。 | 返回的 DataFrame 与存入的数据一致。 |
| **UC-REPO-003** | `save_financial_report` | 测试重复写入相同数据的情况。 | 两次保存完全相同的 DataFrame。 | 数据库通过唯一性约束处理此情况，程序不崩溃。 |

## 3. 集成测试用例

### 3.1 `data_updater.py` 核心流程

-   **测试对象**: `data_updater.py` 的主流程。
-   **测试策略**: 模拟 `akshare` 的 API 响应，并使用内存数据库来测试从数据获取到存储的完整流程。

| 测试用例 ID | 描述 | 步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **IC-DU-001** | 测试 `data_updater` 的完整 happy path。 | 1. 模拟 `akshare` 返回一个包含2只股票的代码列表。 2. 模拟 `akshare` 为这2只股票返回有效的财务报表数据。 3. 运行 `data_updater` 主函数。 | 1. `data_updater` 成功运行并退出。 2. 内存数据库中包含这2只股票的财务数据。 3. 缓存表被清空。 |
| **IC-DU-002** | 测试断点续传功能。 | 1. 模拟 `akshare` 返回一个包含3只股票的代码列表。 2. 首次运行时，模拟其中一只股票的数据获取失败。 3. 再次运行 `data_updater` 主函数。 | 1. 首次运行后，数据库中包含2只股票的数据。 2. 再次运行时，程序应只尝试获取之前失败的那1只股票的数据。 3. 最终数据库中包含全部3只股票的数据。 |

### 3.2 `main.py` 核心流程

-   **测试对象**: `main.py` 和 `Orchestrator` 的主分析流程。
-   **测试策略**: 使用一个预先填充了少量数据的内存数据库，测试从数据读取、计算到图表生成的完整分析流程。

| 测试用例 ID | 描述 | 步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **IC-MAIN-001** | 测试 `main.py` 的完整 happy path。 | 1. 准备一个包含少量（如3只股票）财务数据的内存数据库。 2. 模拟 `plotter.py` 的绘图函数。 3. 运行 `main.py` 并传入一个有效的股票代码。 | 1. `main.py` 成功运行并退出。 2. `Orchestrator` 正确调用了所有依赖模块。 3. 被模拟的 `plotter` 函数被正确调用，且传入了包含计算结果的 DataFrame。 |
| **IC-MAIN-002** | 测试数据库为空时的处理。 | 1. 准备一个空的内存数据库。 2. 运行 `main.py`。 | 1. 程序捕获到数据库为空的异常。 2. 向控制台打印出清晰的提示信息。 3. 程序优雅退出。 |
| **IC-MAIN-003** | 测试中位数缓存机制。 | 1. 准备一个包含财务数据但缓存表为空的内存数据库。 2. 首次运行 `main.py`。 3. 再次运行 `main.py`。 | 1. 首次运行时，`Analyzer` 执行了完整的市场中位数计算。 2. 首次运行后，`indicator_medians` 缓存表中包含了计算结果。 3. 再次运行时，`Analyzer` 应直接从缓存中读取中位数。 |

## 4. 端到端 (E2E) 测试用例

端到端测试旨在验证整个应用在真实环境（或类真实环境）下的工作流程。

| 测试用例 ID | 描述 | 步骤 | 预期结果 |
| :--- | :--- | :--- | :--- |
| **E2E-FULL-001** | 验证生产环境下的完整工作流。 | 1. 确保环境干净（删除旧数据库和图表）。<br>2. 运行 `python data_updater.py --limit 5` 以获取少量（5只）股票的真实数据。<br>3. 检查 `database.sqlite` 是否已创建并包含数据。<br>4. 运行 `python main.py --code <股票代码>`，使用一只已获取的股票。<br>5. 检查输出目录中是否生成了图表文件。 | 1. `data_updater.py` 和 `main.py` 均成功运行。<br>2. 数据库被正确创建和填充。<br>3. 图表文件被成功生成，且内容目视检查合理。 |

## 5. 待确认事项

-   无
