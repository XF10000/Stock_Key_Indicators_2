# 原型验证方案

## 1. 验证目标

本次原型验证旨在解决项目中风险最高、不确定性最大的部分，核心目标如下：

-   **验证数据管道**: 证明我们能成功地从 `akshare` 获取数据，通过 `SQLAlchemy` 存入 SQLite 数据库，并能成功地再读出，验证端到端的数据流。
-   **验证数据标准化**: 证明我们设计的“科目名映射”机制能够有效处理来自 `akshare` 的不一致的财务报表列名。
-   **验证核心计算**: 证明我们能基于存入数据库的数据，正确地计算出一个关键财务指标（ROE），确保数据在整个流程中没有失真。

## 2. 原型范围

为保证验证的聚焦和高效，本次原型将严格限制范围：

-   **数据样本**: 只处理 **3-5 只**有代表性的股票（如：贵州茅台、宁德时代、京东方A），不涉及全市场数据。
-   **功能范围**:
    -   一个简化的数据获取与存储脚本。
    -   一个包含少量映射规则的 `column_mapping.yaml` 配置文件。
    -   一个只实现 `calculate_roe` 方法的 `FinancialCalculator` 类。
    -   一个 Jupyter Notebook (`prototype.ipynb`) 作为主要的交互和验证环境。

## 3. 实施步骤

1.  **环境搭建**: 创建 `requirements.txt` 文件并安装 `akshare`, `pandas`, `sqlalchemy`, `openpyxl` 等核心依赖。
2.  **数据模型定义**: 在 `models.py` 中使用 SQLAlchemy 定义 `balance_sheets` 和 `income_statements` 的表结构。
3.  **数据获取与标准化**: 在 `prototype.ipynb` 中编写代码，实现：
    -   连接 `akshare` 获取指定股票的资产负债表和利润表数据。
    -   加载 `column_mapping.yaml`，对获取到的 DataFrame 进行列名标准化处理。
4.  **数据存储**: 在 `prototype.ipynb` 中继续编写代码，使用 `SQLAlchemy` 将标准化后的数据存入 SQLite 数据库。
5.  **数据读取与计算**: 在 `prototype.ipynb` 中继续编写代码，实现：
    -   从 SQLite 数据库中读出已存储的数据。
    -   调用 `FinancialCalculator.calculate_roe` 方法进行计算。
6.  **结果验证**: 在 Notebook 中将计算出的 ROE 结果与财经网站（如东方财富）公开的数据进行手动比对。

## 4. 验收标准

-   [ ] `prototype.ipynb` 能够无错误地从头运行到尾。
-   [ ] 程序成功创建 `database.sqlite` 文件，并且其中的表结构和数据均符合预期。
-   [ ] 列名标准化功能按预期工作，不一致的科目名（如“研发费用”/“研发支出”）被成功统一。
-   [ ] 计算出的 ROE 值与手动核对的结果在合理误差范围内（±0.1%）一致。

## 5. 交付物

-   `prototype.ipynb`: 包含所有原型代码和验证步骤的 Jupyter Notebook。
-   `database.sqlite`: 包含原型数据的数据库文件。
-   `requirements.txt`: 项目依赖文件。
-   `models.py`: 数据模型定义文件。
-   `column_mapping.yaml`: 科目名映射配置文件。
-   一份简短的《原型验证报告》，总结验证过程和结论。

## 6. 待确认事项

-   无
