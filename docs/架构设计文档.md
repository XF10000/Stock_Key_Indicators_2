# 架构设计文档

## 1. 系统架构

### 1.1 架构图

采用分层架构，将系统划分为表现层、应用层、业务逻辑层、数据访问层和数据存储层。

```
+-------------------------+
|   Presentation Layer    | (main.py - 用户交互)
+-----------+-------------+
            |
+-----------v-------------+
|   Application Layer     | (orchestrator.py - 流程控制)
+-----------+-------------+
            |
+-----------v-------------+      +-------------------------+
|  Business Logic Layer   |----->|   Visualization Layer   |
| (analysis/ - 指标计算)  |      | (visualization/ - 绘图) |
+-----------+-------------+      +-------------------------+
            |
+-----------v-------------+
|   Data Access Layer     |
| (data_provider/ - 数据读写) |
+-----------+-------------+
            |
+-----------v-------------+
|    Data Storage Layer   | (database.sqlite - 数据库)
+-------------------------+
```

### 1.2 模块划分

-   **`main.py` (分析程序入口)**: 聚焦于执行单次分析任务。解析用户输入，调用 `Orchestrator` 进行分析。
-   **`data_updater.py` (数据更新程序入口)**: 独立于主分析程序。负责获取全A股列表，并调用数据访问层更新所有公司的财务数据到数据库。
-   **`orchestrator.py` (应用层 - 调度器)**: 协调各模块按顺序工作，控制整体分析流程。
-   **`data_provider/` (数据访问层)**: 封装数据获取（`akshare_client.py`）和数据库交互（`repository.py`）。
-   **`analysis/` (业务逻辑层)**: 包含核心财务指标计算（`calculator.py`）和统计分析（`analyzer.py`）逻辑。
-   **`visualization/` (可视化层)**: 负责生成静态图表（`plotter.py`）。
-   **`models.py` (数据模型)**: 使用 SQLAlchemy 定义数据库表结构。
-   **`utils/` (通用工具)**: 存放配置加载器、日志记录器等共享功能。

### 1.3 模块交互

**数据更新流程 (独立运行):**

推荐使用 `data_updater_robust.py`（生产环境）：

1.  用户执行 `python data_updater_robust.py --workers 10 --batch-size 50 --batch-pause 30`
2.  加载进度文件 `progress_robust.json`，实现断点续传
3.  `data_updater` 调用 `AkshareClient` 获取全A股列表
4.  过滤已处理的股票（断点续传）
5.  分批处理股票：
    - 使用线程池并发获取数据（可配置并发数）
    - 每个API调用设置30秒超时，避免挂起
    - 通过 `Repository` 将数据存入数据库（线程安全）
    - 实时保存进度到 `progress_robust.json`
    - 每处理N只股票后暂停M秒（防API限流）
6.  生成数据质量报告文件
7.  支持 Ctrl+C 优雅退出，保存当前进度

**核心特性**:
- **超时机制**: API调用30秒超时，避免长时间挂起
- **批次暂停**: 每50只股票暂停30秒，降低API限流风险
- **断点续传**: 实时保存进度，中断后自动继续
- **并发处理**: 10线程并发，5000只股票约6小时完成

**数据分析流程:**
1.  用户执行 `python main.py --code SH600519`。
2.  `main.py` 调用 `Orchestrator`。
3.  `Orchestrator` 首先调用 `Repository` 检查数据库是否为空。如果为空，则提示用户先运行 `data_updater.py` 并退出。
4.  `Orchestrator` 从 `Repository` 获取分析所需的数据（目标公司及全市场数据）。
5.  数据被传递给 `FinancialCalculator` 和 `MarketAnalyzer` 进行计算和分析。
6.  `Orchestrator` 将分析结果传递给 `Plotter` 生成图表。
7.  `main.py` 最终将图表路径呈现给用户。

## 2. 模块接口定义

### 2.1 模块: `data_provider.akshare_client`

```python
from typing import Optional
import pandas as pd

class AkshareClient:
    """封装了与 akshare API 的所有交互，用于获取原始财务报表数据。"""

    def get_financial_report(self, stock_code: str, report_type: str) -> Optional[pd.DataFrame]:
        """获取单个股票指定类型的所有历史财务报表。

        Args:
            stock_code (str): 股票代码 (例如: 'SH600519')。
            report_type (str): 报表类型 ('balance', 'income', 'cash_flow')。

        Returns:
            Optional[pd.DataFrame]: 包含财务报表数据的DataFrame，如果获取失败则返回 None。
        
        Example:
            >>> client = AkshareClient()
            >>> df = client.get_financial_report('SH600519', 'balance')
        """
        pass
```

### 2.2 模块: `data_provider.repository`

```python
from typing import List
import pandas as pd
from sqlalchemy.orm import Session

class Repository:
    """负责数据的持久化和检索，将业务逻辑与数据库实现解耦。"""

    def __init__(self, session: Session):
        """初始化 Repository。

        Args:
            session (Session): SQLAlchemy 的数据库会话对象。
        """
        self.session = session

    def save_financial_report(self, df: pd.DataFrame, report_type: str) -> None:
        """将财务报表数据批量保存到数据库。"""
        pass

    def get_financial_data(self, stock_codes: List[str], report_type: str) -> pd.DataFrame:
        """从数据库中获取指定股票列表的财务数据。"""
        pass
```

### 2.3 模块: `analysis.calculator`

```python
import pandas as pd

class FinancialCalculator:
    """包含所有财务指标的核心计算逻辑。"""

    def calculate_roe(self, income_df: pd.DataFrame, balance_df: pd.DataFrame) -> pd.DataFrame:
        """计算净资产收益率 (ROE)。"""
        pass
    
    # ... 此处将定义其他所有指标的计算方法 ...
```

### 2.4 模块: `analysis.analyzer`

```python
import pandas as pd

class MarketAnalyzer:
    """执行高级统计分析，如计算全市场中位数和历史分位数。

    内部实现了对市场中位数结果的缓存机制。
    """

    def calculate_market_median(self, all_stocks_indicator_df: pd.DataFrame) -> pd.DataFrame:
        """计算指定指标在每个报告期的全市场中位数。"""
        pass

    def calculate_quantile_history(self, target_stock_indicator_df: pd.DataFrame, all_stocks_indicator_df: pd.DataFrame) -> pd.DataFrame:
        """计算目标股票指标在全市场中的历史分位数。"""
        pass
```

### 2.5 模块: `visualization.plotter`

```python
import pandas as pd

class Plotter:
    """接收分析结果数据，生成HTML报告。"""

    def generate_html_report(self, analysis_results: dict, stock_code: str, output_path: str) -> None:
        """生成包含四大指标图表的HTML报告。
        
        Args:
            analysis_results (dict): 包含所有指标分析结果的字典。
            stock_code (str): 目标股票代码。
            output_path (str): HTML文件输出路径。
        """
        pass
    
    def plot_indicator_trend(self, data: pd.DataFrame, title: str) -> str:
        """绘制指标趋势图，返回HTML字符串。"""
        pass
```

### 2.6 模块: `orchestrator`

```python
from typing import List

class Orchestrator:
    """作为总指挥，协调各个模块完成分析任务。"""

    def run_analysis(self, stock_code: str) -> None:
        """执行完整的单只股票分析流程。

        在开始前会检查数据库状态，如果为空则会引发异常并提示用户。
        """
        pass
```

## 3. 数据结构设计

### 3.1 数据库表设计

采用“宽表”模型，为三张核心财务报表分别创建一张独立的数据库表。所有表都包含 `stock_code` 和 `report_date` 字段，并在这两个字段上建立复合唯一索引以提高查询性能。

#### 表1: `balance_sheets` (资产负债表)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String | 股票代码 | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `monetary_capital` | Float | 货币资金 | Nullable |
| `...` | Float | (其他约250个资产负债表科目) | Nullable |

#### 表2: `income_statements` (利润表)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String | 股票代码 | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `total_operating_revenue` | Float | 营业总收入 | Nullable |
| `...` | Float | (其他约200个利润表科目) | Nullable |

#### 表3: `cash_flow_statements` (现金流量表)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String | 股票代码 | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `goods_sell_and_service_render_cash` | Float | 销售商品、提供劳务收到的现金 | Nullable |
| `...` | Float | (其他约150个现金流量表科目) | Nullable |

#### 表4: `stock_info` (股票基本信息)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String(20) | 股票代码 | Not Null, Unique, Index |
| `stock_name` | String(100) | 公司名称 | Not Null |

**用途**:
- 存储股票代码和公司名称的映射关系
- 使报告中可以显示公司名称而非股票代码
- 支持所有A股（5000+只）

**自动维护机制**:
- 所有数据更新器（`data_updater.py`、`data_updater_concurrent.py`、`data_updater_robust.py`）在处理每只股票时会自动保存/更新股票信息
- 无需手动维护，随数据更新自动同步
- 如果股票信息已存在，会自动更新（如公司更名）
- 保存失败不影响财务数据更新

#### 表5: `indicator_medians` (指标中位数缓存)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `indicator_name` | String | 指标的唯一名称 (如 'roe') | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `median_value` | Float | 该指标在该日期的市场中位数 | Nullable |
| `cache_version` | String | 缓存版本号（时间戳） | Not Null, Index |

**缓存策略**:
- 只在新增报告期时计算新的中位数，历史数据不再重新计算
- 每次 `data_updater.py` 运行时生成新的 `cache_version`
- 分析程序读取缓存时，只使用当前版本的缓存数据

## 4. 配置参数

项目将使用 `config.yaml` 统一管理配置参数：

### 4.1 数据库配置
-   `database.path`: 数据库文件路径（默认: "database.sqlite"）

### 4.2 API配置
-   `api.request_delay`: API请求间隔秒数（默认: 0.5）
-   `api.retry_times`: 失败重试次数（默认: 3）
-   `api.retry_delay`: 重试间隔秒数（默认: 5）

### 4.3 数据更新配置
-   `data_updater.batch_size`: 批量写入数据库的批次大小（默认: 100）
-   `data_updater.chunk_size`: 分块处理的股票数量（默认: 1000）

### 4.4 性能配置
-   `performance.max_memory_gb`: 单次加载数据的最大内存GB（默认: 2）
-   `performance.chunk_size`: 分块处理的股票数量（默认: 500）

### 4.5 输出配置
-   `output.html_dir`: HTML报告输出目录（默认: "output/html"）
-   `output.excel_dir`: Excel文件输出目录（默认: "output/excel"）
-   `output.report_dir`: 数据质量报告目录（默认: "output/reports"）

### 4.6 日志配置
-   `logging.level`: 日志级别（默认: "INFO"）
-   `logging.data_update_log`: 数据更新日志路径（默认: "logs/data_update.log"）
-   `logging.calculation_log`: 计算过程日志路径（默认: "logs/calculation.log"）
-   `logging.unmapped_columns_log`: 未映射列名日志路径（默认: "logs/unmapped_columns.log"）

## 5. HTML报告输出规格

### 5.1 报告结构要求

HTML报告由 `visualization/plotter.py` 模块生成，应包含以下内容：

1. **报告头部**
   - 公司名称和股票代码
   - 分析日期和分析年限
   - 基本信息展示区（使用info-box样式）

2. **四大核心指标展示**
   - 每个指标独立成节，使用H2标题
   - 每个指标包含：基本描述、计算方法说明、深度分析说明（可展开）、图表展示

3. **报告尾部**
   - 报告生成时间
   - 数据来源说明

### 5.2 指标深度分析说明要求

**实现方式**：
- 使用HTML5原生 `<details>` 和 `<summary>` 标签实现可展开/隐藏功能
- 默认状态为折叠，用户点击后展开
- 无需JavaScript，浏览器原生支持

**内容来源**：
- 深度分析说明的具体内容参见《需求澄清报告》中各指标的"深度分析说明"部分
- 内容应完整复制，确保与需求文档保持一致

**样式要求**：
- 使用浅色背景（如 `#f8f9fa`）区分展开区域
- 左侧添加彩色边框（如 `4px solid #4CAF50`）作为视觉标识
- summary文字使用醒目颜色（如 `#4CAF50`），鼠标悬停时变色
- 内容使用有序列表（`<ol>`）格式，每个要点加粗标题
- 添加emoji图标（如📊）作为视觉提示

**四大指标的深度分析内容**：

#### 指标1：报表逻辑一致性检验暨回款周期
1. **10年数据透视**：应收账款周转率在全A样本中呈对数正态分布，真实性具备保障
2. **虚增收入检验逻辑**：应收账款周转率=营业收入/应收账款，通常大于1，因此如果通过虚增应收账款来虚增营业收入，分子分母同时增加相同的值，应收账款周转率大概率下降。应收账款周转率下降意味着企业在产业链上的竞争力减弱
3. **毛利率交叉验证**：但是营业成本很难随营业收入等比例虚增（折旧源于历史成本，员工工资需要和社保数据对应），如果通过虚增应收账款来虚增营业收入，毛利率可能上升，这又意味着企业议价权提高，与应收账款周转率指向不一致
4. **一致性检验**：因此，检验应收账款周转率和毛利率走势一致性，是重要的报表质量验证方法，不一致不一定有问题，但是需要给出合理解释

#### 指标2：再投资质量暨跑冒滴漏风险检验
1. **10年数据透视**：营业收入/(固定资产+无形资产)在全A样本中呈对数正态分布
2. **影响因素**：影响固定资产周转率的因素包括单位产能造价、产能利用率、产品单价，一方面反映再投资质量，同时可以反映跑冒滴漏程度
3. **三步循环法检验**：如果上市公司采用了完整的"三步循环法"一般会将虚增的利润(或者跑冒滴漏)变成了固定资产、无形资产等长期资产，再通过未来折旧或者减值消化，由于资产负债表是累积式的，周转率指标会发生趋势性下降
4. **分析要点**：无论是哪种情况，固定资产+无形资产周转率下降，尤其是单个公司在全A样本中的分位数下降，都代表存量资产以及再投资质量下降，是重大的负面指标；反之则意味着资产利用效率、产业竞争力实打实改善

#### 指标3：产业链地位检验暨资金运用能力
1. **10年数据透视**：营运净资本占总资产的比例在全A样本呈正态分布，真实性具备保障
2. **双重含义**：营运净资本(应收账款+应收票据+应收款项融资+合同资产-应付账款-应付票据-合同负债)占比一方面体现上市公司资金运用效率，即不能创造收益的在途资金占比，另一方面反映公司在上下游产业链中的地位
3. **分布特征**：该指标是所有指标中，全A样本分布"最正态"的一个，且全A样本中位数非常接近零
4. **龙头验证**：尤其注意单个公司的该指标在全A样本中的分位数的边际变化。如果该公司在估值中的叙事是"龙头优势明显、强者恒强"，营运净资本占比在全A样本中的分位数就应该持续下降，或者绝对分位数很低，否则就是重大不一致，需要找到充足的理由解释

#### 指标4：真实盈利水平暨现金流创造能力
1. **10年数据透视**：经营性现金流量净额/总资产在全A样本呈正态分布，真实性具备保障
2. **等价ROA**：经营性现金流量净额中包含财务费用，因此分母用总资产，该指标相当于ROA。如之前所述，全A样本ROE存在调节的可能性，该指标更能体现资产的现金流创造能力
3. **市场基准**：2024年全A样本该指标的中位数只有4.3%，反映了A股市场加杠杆之前的"平均盈利水平"；而2025Q1分布则呈现明显的左侧厚尾(历年一季度都有这个特点)，中位数接近零，即大部分公司一季度回款一般，如果单个公司一季度回款较好，则尤为不易
4. **叙事一致性**：该指标的绝对值高低本身无谓多空，而是要对比财报中的画像与估值中隐含的叙事的一致性，包括历史趋势与全A样本分位数走势

### 5.3 实现示例

```html
<details>
    <summary>📊 点击展开：指标1深度分析说明</summary>
    <div class="analysis-content">
        <ol>
            <li><strong>10年数据透视：</strong>应收账款周转率在全A样本中呈对数正态分布，真实性具备保障</li>
            <li><strong>虚增收入检验逻辑：</strong>应收账款周转率=营业收入/应收账款...</li>
            <!-- 其他要点 -->
        </ol>
    </div>
</details>
```

### 5.4 CSS样式要求

```css
details {
    background-color: #f8f9fa;
    border-left: 4px solid #4CAF50;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
}

summary {
    cursor: pointer;
    font-weight: bold;
    color: #4CAF50;
    padding: 5px 0;
    user-select: none;
}

summary:hover {
    color: #45a049;
}

.analysis-content {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #ddd;
    line-height: 1.8;
}

.analysis-content ol {
    padding-left: 20px;
}

.analysis-content li {
    margin-bottom: 12px;
    color: #444;
}
```

## 6. 待确认事项

-   无
