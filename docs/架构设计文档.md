# 架构设计文档

## 1. 系统架构

### 1.1 架构图

采用分层架构，将系统划分为表现层、应用层、业务逻辑层、数据访问层和数据存储层。

```
+-------------------------+
|   Presentation Layer    | (main.py - 用户交互)
+-----------+-------------+
            |
+-----------v-------------+
|   Application Layer     | (orchestrator.py - 流程控制)
+-----------+-------------+
            |
+-----------v-------------+      +-------------------------+
|  Business Logic Layer   |----->|   Visualization Layer   |
| (analysis/ - 指标计算)  |      | (visualization/ - 绘图) |
+-----------+-------------+      +-------------------------+
            |
+-----------v-------------+
|   Data Access Layer     |
| (data_provider/ - 数据读写) |
+-----------+-------------+
            |
+-----------v-------------+
|    Data Storage Layer   | (database.sqlite - 数据库)
+-------------------------+
```

### 1.2 模块划分

-   **`main.py` (分析程序入口)**: 聚焦于执行单次分析任务。解析用户输入，调用 `Orchestrator` 进行分析。
-   **`data_updater.py` (数据更新程序入口)**: 独立于主分析程序。负责获取全A股列表，并调用数据访问层更新所有公司的财务数据到数据库。
-   **`orchestrator.py` (应用层 - 调度器)**: 协调各模块按顺序工作，控制整体分析流程。
-   **`data_provider/` (数据访问层)**: 封装数据获取（`akshare_client.py`）和数据库交互（`repository.py`）。
-   **`analysis/` (业务逻辑层)**: 包含核心财务指标计算（`calculator.py`）和统计分析（`analyzer.py`）逻辑。
-   **`visualization/` (可视化层)**: 负责生成静态图表（`plotter.py`）。
-   **`models.py` (数据模型)**: 使用 SQLAlchemy 定义数据库表结构。
-   **`utils/` (通用工具)**: 存放配置加载器、日志记录器等共享功能。

### 1.3 模块交互

**数据更新流程 (独立运行):**

推荐使用 `data_updater_robust.py`（生产环境）：

1.  用户执行 `python data_updater_robust.py --workers 10 --batch-size 50 --batch-pause 30`
2.  加载进度文件 `progress_robust.json`，实现断点续传
3.  `data_updater` 调用 `AkshareClient` 获取全A股列表
4.  过滤已处理的股票（断点续传）
5.  分批处理股票：
    - 使用线程池并发获取数据（可配置并发数）
    - 每个API调用设置30秒超时，避免挂起
    - 通过 `Repository` 将数据存入数据库（线程安全）
    - 实时保存进度到 `progress_robust.json`
    - 每处理N只股票后暂停M秒（防API限流）
6.  生成数据质量报告文件
7.  支持 Ctrl+C 优雅退出，保存当前进度

**核心特性**:
- **超时机制**: API调用30秒超时，避免长时间挂起
- **批次暂停**: 每50只股票暂停30秒，降低API限流风险
- **断点续传**: 实时保存进度，中断后自动继续
- **并发处理**: 10线程并发，5000只股票约6小时完成

**数据分析流程:**
1.  用户执行 `python main.py --code SH600519`。
2.  `main.py` 调用 `Orchestrator`。
3.  `Orchestrator` 首先调用 `Repository` 检查数据库是否为空。如果为空，则提示用户先运行 `data_updater.py` 并退出。
4.  `Orchestrator` 从 `Repository` 获取分析所需的数据（目标公司及全市场数据）。
5.  数据被传递给 `FinancialCalculator` 和 `MarketAnalyzer` 进行计算和分析。
6.  `Orchestrator` 将分析结果传递给 `Plotter` 生成图表。
7.  `main.py` 最终将图表路径呈现给用户。

## 2. 模块接口定义

### 2.1 模块: `data_provider.akshare_client`

```python
from typing import Optional
import pandas as pd

class AkshareClient:
    """封装了与 akshare API 的所有交互，用于获取原始财务报表数据。"""

    def get_financial_report(self, stock_code: str, report_type: str) -> Optional[pd.DataFrame]:
        """获取单个股票指定类型的所有历史财务报表。

        Args:
            stock_code (str): 股票代码 (例如: 'SH600519')。
            report_type (str): 报表类型 ('balance', 'income', 'cash_flow')。

        Returns:
            Optional[pd.DataFrame]: 包含财务报表数据的DataFrame，如果获取失败则返回 None。
        
        Example:
            >>> client = AkshareClient()
            >>> df = client.get_financial_report('SH600519', 'balance')
        """
        pass
```

### 2.2 模块: `data_provider.repository`

```python
from typing import List
import pandas as pd
from sqlalchemy.orm import Session

class Repository:
    """负责数据的持久化和检索，将业务逻辑与数据库实现解耦。"""

    def __init__(self, session: Session):
        """初始化 Repository。

        Args:
            session (Session): SQLAlchemy 的数据库会话对象。
        """
        self.session = session

    def save_financial_report(self, df: pd.DataFrame, report_type: str) -> None:
        """将财务报表数据批量保存到数据库。"""
        pass

    def get_financial_data(self, stock_codes: List[str], report_type: str) -> pd.DataFrame:
        """从数据库中获取指定股票列表的财务数据。"""
        pass
```

### 2.3 模块: `analysis.calculator`

```python
import pandas as pd

class FinancialCalculator:
    """包含所有财务指标的核心计算逻辑。"""

    def calculate_roe(self, income_df: pd.DataFrame, balance_df: pd.DataFrame) -> pd.DataFrame:
        """计算净资产收益率 (ROE)。"""
        pass
    
    # ... 此处将定义其他所有指标的计算方法 ...
```

### 2.4 模块: `analysis.analyzer`

```python
import pandas as pd

class MarketAnalyzer:
    """执行高级统计分析，如计算全市场中位数和历史分位数。

    内部实现了对市场中位数结果的缓存机制。
    """

    def calculate_market_median(self, all_stocks_indicator_df: pd.DataFrame) -> pd.DataFrame:
        """计算指定指标在每个报告期的全市场中位数。"""
        pass

    def calculate_quantile_history(self, target_stock_indicator_df: pd.DataFrame, all_stocks_indicator_df: pd.DataFrame) -> pd.DataFrame:
        """计算目标股票指标在全市场中的历史分位数。"""
        pass
```

### 2.5 模块: `visualization.plotter`

```python
import pandas as pd

class Plotter:
    """接收分析结果数据，生成HTML报告。"""

    def generate_html_report(self, analysis_results: dict, stock_code: str, output_path: str) -> None:
        """生成包含四大指标图表的HTML报告。
        
        Args:
            analysis_results (dict): 包含所有指标分析结果的字典。
            stock_code (str): 目标股票代码。
            output_path (str): HTML文件输出路径。
        """
        pass
    
    def plot_indicator_trend(self, data: pd.DataFrame, title: str) -> str:
        """绘制指标趋势图，返回HTML字符串。"""
        pass
```

### 2.6 模块: `orchestrator`

```python
from typing import List

class Orchestrator:
    """作为总指挥，协调各个模块完成分析任务。"""

    def run_analysis(self, stock_code: str) -> None:
        """执行完整的单只股票分析流程。

        在开始前会检查数据库状态，如果为空则会引发异常并提示用户。
        """
        pass
```

## 3. 数据结构设计

### 3.1 数据库表设计

采用“宽表”模型，为三张核心财务报表分别创建一张独立的数据库表。所有表都包含 `stock_code` 和 `report_date` 字段，并在这两个字段上建立复合唯一索引以提高查询性能。

#### 表1: `balance_sheets` (资产负债表)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String | 股票代码 | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `monetary_capital` | Float | 货币资金 | Nullable |
| `...` | Float | (其他约250个资产负债表科目) | Nullable |

#### 表2: `income_statements` (利润表)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String | 股票代码 | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `total_operating_revenue` | Float | 营业总收入 | Nullable |
| `...` | Float | (其他约200个利润表科目) | Nullable |

#### 表3: `cash_flow_statements` (现金流量表)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `stock_code` | String | 股票代码 | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `goods_sell_and_service_render_cash` | Float | 销售商品、提供劳务收到的现金 | Nullable |
| `...` | Float | (其他约150个现金流量表科目) | Nullable |

#### 表4: `indicator_medians` (指标中位数缓存)

| 字段名 | 类型 | 说明 | 约束 |
| :--- | :--- | :--- | :--- |
| `id` | Integer | 主键 | Primary Key |
| `indicator_name` | String | 指标的唯一名称 (如 'roe') | Not Null, Index |
| `report_date` | Date | 报告日期 | Not Null, Index |
| `median_value` | Float | 该指标在该日期的市场中位数 | Nullable |
| `cache_version` | String | 缓存版本号（时间戳） | Not Null, Index |

**缓存策略**:
- 只在新增报告期时计算新的中位数，历史数据不再重新计算
- 每次 `data_updater.py` 运行时生成新的 `cache_version`
- 分析程序读取缓存时，只使用当前版本的缓存数据

## 4. 配置参数

项目将使用 `config.yaml` 统一管理配置参数：

### 4.1 数据库配置
-   `database.path`: 数据库文件路径（默认: "database.sqlite"）

### 4.2 API配置
-   `api.request_delay`: API请求间隔秒数（默认: 0.5）
-   `api.retry_times`: 失败重试次数（默认: 3）
-   `api.retry_delay`: 重试间隔秒数（默认: 5）

### 4.3 数据更新配置
-   `data_updater.batch_size`: 批量写入数据库的批次大小（默认: 100）
-   `data_updater.chunk_size`: 分块处理的股票数量（默认: 1000）

### 4.4 性能配置
-   `performance.max_memory_gb`: 单次加载数据的最大内存GB（默认: 2）
-   `performance.chunk_size`: 分块处理的股票数量（默认: 500）

### 4.5 输出配置
-   `output.html_dir`: HTML报告输出目录（默认: "output/html"）
-   `output.excel_dir`: Excel文件输出目录（默认: "output/excel"）
-   `output.report_dir`: 数据质量报告目录（默认: "output/reports"）

### 4.6 日志配置
-   `logging.level`: 日志级别（默认: "INFO"）
-   `logging.data_update_log`: 数据更新日志路径（默认: "logs/data_update.log"）
-   `logging.calculation_log`: 计算过程日志路径（默认: "logs/calculation.log"）
-   `logging.unmapped_columns_log`: 未映射列名日志路径（默认: "logs/unmapped_columns.log"）

## 5. 待确认事项

-   无
